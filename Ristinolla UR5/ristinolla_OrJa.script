def ristinolla_OrJa():
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_tool_voltage(0)
  set_input_actions_to_default()
  set_tcp(p[0.0,0.0,0.18,0.0,0.0,0.0])
  set_payload(1.2)
  set_gravity([0.0, 0.0, 9.82])
  global gameMark=1
  global Point_1=p[-0.1666117576483284,-0.5934685257089035,9.511670789417448E-4,0.13929061959008146,-2.927294556433711,0.9231747133033774]
  global Point_2=p[-0.16655272334286833,-0.593461694219597,9.242204225230755E-4,0.13944982622205215,-2.927359498435791,0.9230689302518044]
  global Pointti=p[-0.0029287699747055085,-0.6845060114792947,-0.011139743129272572,0.07744830131189127,3.006069013970477,-0.667023865359897]
  global alotusChip_OrJa=p[0.10037872110982342,-0.3652595474681671,0.018681602037294076,-2.9210179361849824,0.014263085224794485,-0.034627349724551046]
  global asd=p[-0.24700518535787788,-0.665637067400333,0.01147516561505102,-0.063309869372335,-2.9921332164520096,0.9508643470296079]
  global calibFeature=p[-0.14570467225721198,-0.5689003818096249,-0.019641537904121764,0.14024744810157055,-3.1089712522351847,0.26238300778726265]
  global cameraPos=p[-0.14573128759984544,-0.5689123746868487,-0.019639654186424466,0.14008527146627278,-3.1089029554265406,0.26243931137218496]
  global nappulat_OrJa=p[-0.2607920425887187,-0.31551328938356726,0.021374773672193675,-2.980799603239241,-0.011780808039767682,0.08743075633525293]
  global nappulat_point=p[0.11613383488293742,-0.5950649053610393,0.00974099678665688,-0.07047337278378776,3.0305416759498356,-0.8149957263308766]
  global ruudukko2_OrJa=p[-0.0029355586540198465,-0.6845106766845338,-0.011173065082859784,0.07743838940405703,3.0061439383605966,-0.6671454616822479]
  global ruudukko_OrJa=p[0.10039664406596355,-0.365266731122835,0.01870529675235416,-2.9211393544597293,0.014161282372825677,-0.034652376269687535]
  global ryhm2=p[-0.0028870787203939888,-0.6844806639267257,-0.011248149859884926,0.07730822905491662,3.006122882998546,-0.6668875432231716]
  global snap_1=p[-0.0475565298942241,-0.5998753829842588,0.00794906969987666,-0.19567402485597613,2.959966044160744,-0.8236184133355082]
  global snapshot=p[-0.2986721182186919,-0.13652482221509232,0.3024405959389358,-0.021118205183970236,-2.998389162372187,0.560875916749157]
  global varFeature=p[-0.09220132558177906,-0.5451017759504818,0.031571063467345145,0.14027997601935116,-3.10903348022427,0.26237921610291637]
  # begin: URCap Installation Node
  #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
  #   Type: Camera
  
  ###########################################
  #######Vision urcap preamble start########
  
  logging_service = rpc_factory("xmlrpc","http://127.0.0.1:4747")
  # Converts a pose relative to the flange in the base frame.
  def get_T_in_base_from_flange(T_x_in_flange):
  
    T_flange_in_base = get_actual_tool_flange_pose()
  
    T_x_in_base = pose_trans(T_flange_in_base, T_x_in_flange)
  
    return T_x_in_base
  end
  
  # Search pose cartesian (camera pose)
  snapshot = p[-0.282118, -0.0717273, 0.469518, -0.0210867, -2.99849, 0.560902]
  ruudukko_OrJa = p[-0.143703, -0.538668, 0.15779, 0.140292, -3.10891, 0.262464]
  snap_1 = p[-0.0645408, -0.508088, 0.161833, -0.195826, 2.96005, -0.82357]
  Point_1 = p[-0.159655, -0.489977, 0.148056, 0.139397, -2.9273, 0.923095]
  nappulat_OrJa = p[-0.250175, -0.344039, 0.198793, -2.98084, -0.0118643, 0.0873949]
  ruudukko2_OrJa = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
  ryhm2 = p[0.045402, -0.560653, 0.140965, 0.0891946, -2.94113, 0.794365]
  Pointti = p[0.045389, -0.560657, 0.140956, 0.0892006, -2.94112, 0.794306]
  nappulat_point = p[0.113559, -0.504846, 0.165462, -0.0703783, 3.03057, -0.815069]
  T_camera_in_flange = p[0.0, 0.05, 0.05, -0.5, 0.0, 0.0]
  snapshot_position_offset = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  ignore_snapshot_position = False
  
  # Open connection with vision service
  xmlrpc_server=rpc_factory("xmlrpc","http://127.0.0.1:4242")
  
  #######Vision urcap preamble end##########
  ###########################################
  
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
  #   Type: Gripper
  
  ###########################################
  #######Gripper URCap preamble start########
  #######Version null########
  
  #aliases for the gripper variable names
  ACT = 1
  GTO = 2
  ATR = 3
  ARD = 4
  FOR = 5
  SPE = 6
  OBJ = 7
  STA = 8
  FLT = 9
  POS = 10
  PRE = 11
  LBP = 12
  LRD = 13
  LBL = 14
  LGN = 15
  MSC = 16
  
  def rq_init_connection(gripper_sid=9, gripper_socket="1"):
      socket_open("127.0.0.1",63352, gripper_socket)
      socket_set_var("SID", gripper_sid,  gripper_socket)
      ack = socket_read_byte_list(3, gripper_socket)
  end
  
  def rq_set_sid(gripper_sid=9, gripper_socket="1"):
      socket_set_var("SID", gripper_sid,  gripper_socket)
      sync()
      ack = socket_read_byte_list(3, gripper_socket)
      return is_ack(ack)
  end
  
  def rq_activate(gripper_socket="1"):
      rq_gripper_act = 0
  
      if (not rq_is_gripper_activated(gripper_socket)):
         rq_reset(gripper_socket)
  
         while(socket_get_var("ACT",gripper_socket) == 1):
            sleep(0.1)
            rq_reset(gripper_socket)
         end
      end
  
      rq_set_var(ACT,1, gripper_socket)
  end
  
  def rq_activate_and_wait(gripper_socket="1"):
      rq_activate(gripper_socket)
  
      while(not rq_is_gripper_activated(gripper_socket)):
          # wait for activation completed
      end
  end
  
  def rq_scan_block():
      gripper_socket = "scn_block_socket"
      socket_open("127.0.0.1", 63352, gripper_socket)
      socket_send_string("SET SCN_BLOCK", gripper_socket)
      sync()
      ack_test = socket_read_byte_list(3, gripper_socket)
  
      retry_counter = 0
  
      while(not is_ack(ack_test) and retry_counter < 5):
          socket_send_string("SET SCN_BLOCK", gripper_socket)
          sync()
          ack_test = socket_read_byte_list(3, gripper_socket)
          retry_counter = retry_counter + 1
      end
  
      socket_close("scn_block_socket")
  end
  
  def rq_stop(gripper_socket="1"):
  	rq_set_var(GTO,0, gripper_socket)
  end
  
  def rq_reset(gripper_socket="1"):
      rq_gripper_act = 0
      rq_obj_detect = 0
      rq_mov_complete = 0
  
      rq_set_var(ACT,0, gripper_socket)
      rq_set_var(ATR,0, gripper_socket)
  end
  
  def rq_auto_release_open_and_wait(gripper_socket="1"):
      rq_set_var(ARD,0, gripper_socket)
      rq_set_var(ACT,1, gripper_socket)
      rq_set_var(ATR,1, gripper_socket)
  
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      while(not is_FLT_autorelease_completed(gFLT)):
          gFLT = rq_get_var(FLT, 2, gripper_socket)
      end
  end
  
  def rq_auto_release_close_and_wait(gripper_socket="1"):
      rq_set_var(ARD,1, gripper_socket)
      rq_set_var(ACT,1, gripper_socket)
      rq_set_var(ATR,1, gripper_socket)
  
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      while(not is_FLT_autorelease_completed(gFLT)):
          gFLT = rq_get_var(FLT, 2, gripper_socket)
      end
  end
  
  def rq_set_force(force, gripper_socket="1"):
      rq_set_var(FOR,force, gripper_socket)
  end
  
  def rq_set_speed(speed, gripper_socket="1"):
  	rq_set_var(SPE,speed, gripper_socket)
  end
  
  def rq_open(gripper_socket="1"):
  	rq_move(0, gripper_socket)
  end
  
  def rq_close(gripper_socket="1"):
  	rq_move(255, gripper_socket)
  end
  
  def rq_open_and_wait(gripper_socket="1"):
  	rq_move_and_wait(0, gripper_socket)
  end
  
  def rq_close_and_wait(gripper_socket="1"):
  	rq_move_and_wait(255, gripper_socket)
  end
  
  def rq_move(pos, gripper_socket="1"):
  	rq_mov_complete = 0
  	rq_obj_detect = 0
  
  	rq_set_pos(pos, gripper_socket)
  	rq_go_to(gripper_socket)
  end
  
  def rq_move_and_wait(pos, gripper_socket="1"):
  	rq_move(pos, gripper_socket)
  
  	while (not rq_is_motion_complete(gripper_socket)):
  		# wait for motion completed
  		sleep(0.01)
  		sync()
  	end
  
  	# following code used for compatibility with previous versions
  	rq_is_object_detected(gripper_socket)
  
  	if (rq_obj_detect != 1):
  		rq_mov_complete = 1
  	end
  end
  
  def rq_wait_for_pos(pos, gripper_socket="1"):
  	gPRE = rq_get_var(PRE, 3, gripper_socket)
  	pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  
  	while (pre != pos):
          rq_set_var(POS, pos, gripper_socket)
  		gPRE = rq_get_var(PRE, 3, gripper_socket)
  		pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  		sync()
  	end
  
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
  		# wait for motion completed
  		sleep(0.01)
  		sync()
  	end
  
  	# following code used for compatibility with previous versions
  	rq_is_object_detected(gripper_socket)
  
  	if (rq_obj_detect != 1):
  		rq_mov_complete = 1
  	end
  end
  
  def rq_wait(gripper_socket="1"):
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
  		# wait for motion completed
  		sleep(0.01)
  		sync()
  	end
  
  	# following code used for compatibility with previous versions
  	rq_is_object_detected(gripper_socket)
  
  	if (rq_obj_detect != 1):
  		rq_mov_complete = 1
  	end
  end
  
  def rq_go_to(gripper_socket="1"):
  	rq_set_var(GTO,1, gripper_socket)
  end
  
  # set the position
  def rq_set_pos(pos, gripper_socket="1"):
  	rq_set_var(POS, pos, gripper_socket)
  
  	gPRE = rq_get_var(PRE, 3, gripper_socket)
  	pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  
  	while (pre != pos):
          rq_set_var(POS, pos, gripper_socket)
  		gPRE = rq_get_var(PRE, 3, gripper_socket)
  		pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  		sync()
  	end
  end
  
  # set the position, speed and force
  def rq_set_pos_spd_for(pos, speed, force, gripper_socket="1"):
     rq_send_pos_spd_for(pos, speed, force, gripper_socket)
  
     ack = socket_read_byte_list(3, gripper_socket)
  
     while(is_not_ack(ack)):
        rq_send_pos_spd_for(pos, speed, force, gripper_socket)
     	  ack = socket_read_byte_list(3, gripper_socket)
     end
  end
  
  def rq_set_gripper_max_current_mA(current_mA, gripper_socket="1"):
      current = floor(current_mA / 10)
      rq_set_var(MSC, current, gripper_socket)
      sleep(1.5)
  end
  
  def rq_get_gripper_max_current_mA(gripper_socket="1"):
      socket_send_string("GET MSC",gripper_socket)
  	sync()
  	var_value = socket_read_byte_list(3, gripper_socket)
  
      current = rq_list_of_bytes_to_value(var_value)
  
      if(current == -1):
          current_mA = current
      else:
          current_mA = current * 10
      end
  
      return current_mA
  end
  
  def rq_list_of_bytes_to_value(list_of_bytes):
      value = -1
  
      # response list length
      if (list_of_bytes[0] == 1):
          value = list_of_bytes[1] - 48
      elif (list_of_bytes[0] == 2):
          value = (list_of_bytes[1] - 48) * 10 + (list_of_bytes[2] - 48)
      elif (list_of_bytes[0] == 3):
          value = (list_of_bytes[1] - 48) * 100 + (list_of_bytes[2] - 48) * 10 + (list_of_bytes[3] - 48)
      end
  
  	return value
  end
  
  # send the position, speed and force
  def rq_send_pos_spd_for(pos, speed, force, gripper_socket="1"):
  
     socket_send_string("SET POS", gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string(pos, gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string("SPE", gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string(speed, gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string("FOR", gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string(force, gripper_socket)
     socket_send_byte(10, gripper_socket)
  
  end
  
  def rq_is_motion_complete(gripper_socket="1"):
  	rq_mov_complete = 0
  
  	gOBJ = rq_get_var(OBJ, 1, gripper_socket)
  	sleep(0.01)
  
  	if (is_OBJ_gripper_at_position(gOBJ)):
  		rq_mov_complete = 1
  		return True
  	end
  
  	if (is_OBJ_object_detected(gOBJ)):
  		rq_mov_complete = 1
  		return True
  	end
  
  	return False
  
  end
  
  def rq_is_gripper_activated(gripper_socket="1"):
  	gSTA = rq_get_var(STA, 1, gripper_socket)
  
  	if(is_STA_gripper_activated(gSTA)):
  		rq_gripper_act = 1
  		return True
  	else:
  		rq_gripper_act = 0
  		return False
  	end
  end
  
  def rq_is_object_detected(gripper_socket="1"):
  	gOBJ = rq_get_var(OBJ, 1, gripper_socket)
  
  	if(is_OBJ_object_detected(gOBJ)):
  		rq_obj_detect = 1
  		return True
  	else:
  		rq_obj_detect = 0
  		return False
  	end
  end
  
  def rq_current_pos(gripper_socket="1"):
  	rq_pos = socket_get_var("POS",gripper_socket)
  	sync()
      return rq_pos
  end
  
  def rq_motor_current(gripper_socket="1"):
  	rq_current = socket_get_var("COU",gripper_socket)
  	sync()
      return rq_current * 10
  end
  
  def rq_print_gripper_fault_code(gripper_socket="1"):
  	gFLT = rq_get_var(FLT, 2, gripper_socket)
  
  	if(is_FLT_no_fault(gFLT)):
  		textmsg("Gripper Fault : ", "No Fault (0x00)")
  	elif (is_FLT_action_delayed(gFLT)):
  		textmsg("Gripper Fault : ", "Priority Fault: Action delayed, initialization must be completed prior to action (0x05)")
  	elif (is_FLT_not_activated(gFLT)):
  		textmsg("Gripper Fault : ", "Priority Fault: The activation must be set prior to action (0x07)")
  	elif (is_FLT_autorelease_in_progress(gFLT)):
  		textmsg("Gripper Fault : ", "Minor Fault: Automatic release in progress (0x0B)")
  	elif (is_FLT_overcurrent(gFLT)):
  		textmsg("Gripper Fault : ", "Minor Fault: Overcurrent protection tiggered (0x0E)")
  	elif (is_FLT_autorelease_completed(gFLT)):
  		textmsg("Gripper Fault : ", "Major Fault: Automatic release completed (0x0F)")
  	else:
  		textmsg("Gripper Fault : ", "Unkwown Fault")
  	end
  end
  
  def rq_print_gripper_num_cycles(gripper_socket="1"):
  	socket_send_string("GET NCY",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  
  	if(string_from_server == "0"):
  		textmsg("Gripper Cycle Number : ", "Number of cycles is unreachable.")
  	else:
  		textmsg("Gripper Cycle Number : ", string_from_server)
  	end
  end
  
  def rq_print_gripper_driver_state(gripper_socket="1"):
  	socket_send_string("GET DST",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  
  	if(string_from_server == "0"):
  		textmsg("Gripper Driver State : ", "RQ_STATE_INIT")
  	elif(string_from_server == "1"):
  		textmsg("Gripper Driver State : ", "RQ_STATE_LISTEN")
  	elif(string_from_server == "2"):
  		textmsg("Gripper Driver State : ", "RQ_STATE_READ_INFO")
  	elif(string_from_server == "3"):
  		textmsg("Gripper Driver State : ", "RQ_STATE_ACTIVATION")
  	else:
  		textmsg("Gripper Driver State : ", "RQ_STATE_RUN")
  	end
  end
  
  def rq_print_gripper_serial_number(gripper_socket="1"):
  	socket_send_string("GET SNU",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  	textmsg("Gripper Serial Number : ", string_from_server)
  end
  
  def rq_print_gripper_firmware_version(gripper_socket="1"):
  	socket_send_string("GET FWV",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  	textmsg("Gripper Firmware Version : ", string_from_server)
  end
  
  def rq_print_gripper_driver_version(gripper_socket="1"):
  	socket_send_string("GET VER",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  	textmsg("Gripper Driver Version : ", string_from_server)
  end
  
  def rq_print_gripper_probleme_connection(gripper_socket="1"):
  	socket_send_string("GET PCO",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  	if (string_from_server == "0"):
  		textmsg("Gripper Connection State : ", "No connection problem detected")
  	else:
  		textmsg("Gripper Connection State : ", "Connection problem detected")
  	end
  end
  
  # Returns True if list_of_bytes is [3, 'a', 'c', 'k']
  def is_ack(list_of_bytes):
  
  	# list length is not 3
  	if (list_of_bytes[0] != 3):
  		return False
  	end
  
  	# first byte not is 'a'?
  	if (list_of_bytes[1] != 97):
  		return False
  	end
  
  	# first byte not is 'c'?
  	if (list_of_bytes[2] != 99):
  		return False
  	end
  
  	# first byte not is 'k'?
  	if (list_of_bytes[3] != 107):
  		return False
  	end
  
  	return True
  end
  
  # Returns True if list_of_bytes is not [3, 'a', 'c', 'k']
  def is_not_ack(list_of_bytes):
  	if (is_ack(list_of_bytes)):
  		return False
  	else:
  		return True
  	end
  end
  
  def is_STA_gripper_activated (list_of_bytes):
  
  	# list length is not 1
  	if (list_of_bytes[0] != 1):
  		return False
  	end
  
  	# byte is '3'?
  	if (list_of_bytes[1] == 51):
  		return True
  	end
  
  	return False
  end
  
  # Returns True if list_of_byte is [1, '1'] or [1, '2']
  # Used to test OBJ = 0x1 or OBJ = 0x2
  def is_OBJ_object_detected (list_of_bytes):
  
  	# list length is not 1
  	if (list_of_bytes[0] != 1):
  		return False
  	end
  
  	# byte is '2'?
  	if (list_of_bytes[1] == 50):
  		return True
  	end
  
  	# byte is '1'?
  	if (list_of_bytes[1]  == 49):
  		return True
  	end
  
  	return False
  
  end
  
  # Returns True if list_of_byte is [1, '3']
  # Used to test OBJ = 0x3
  def is_OBJ_gripper_at_position (list_of_bytes):
  
  	# list length is not 1
  	if (list_of_bytes[0] != 1):
  		return False
  	end
  
  	# byte is '3'?
  	if (list_of_bytes[1] == 51):
  		return True
  	end
  
  	return False
  end
  
  def is_not_OBJ_gripper_at_position (list_of_bytes):
  
  	if (is_OBJ_gripper_at_position(list_of_bytes)):
  		return False
  	else:
  		return True
  	end
  end
  
  def is_FLT_no_fault(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '0'?
  	if (list_of_bytes[1] != 48):
  		return False
  	end
  
  	# second byte is '0'?
  	if (list_of_bytes[2] != 48):
  		return False
  	end
  
  	return True
  
  end
  
  def is_FLT_action_delayed(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '0'?
  	if (list_of_bytes[1] != 48):
  		return False
  	end
  
  	# second byte is '5'?
  	if (list_of_bytes[2] != 53):
  		return False
  	end
  
  	return True
  end
  
  def is_FLT_not_activated(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '0'?
  	if (list_of_bytes[1] != 48):
  		return False
  	end
  
  	# second byte is '7'?
  	if (list_of_bytes[2] != 55):
  		return False
  	end
  
  	return True
  end
  
  def is_FLT_autorelease_in_progress(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '1'?
  	if (list_of_bytes[1] != 49):
  		return False
  	end
  
  	# second byte is '1'?
  	if (list_of_bytes[2] != 49):
  		return False
  	end
  
  	return True
  
  end
  
  def is_FLT_overcurrent(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '1'?
  	if (list_of_bytes[1] != 49):
  		return False
  	end
  
  	# second byte is '4'?
  	if (list_of_bytes[2] != 52):
  		return False
  	end
  
  	return True
  
  end
  
  def is_FLT_autorelease_completed(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '1'?
  	if (list_of_bytes[1] != 49):
  		return False
  	end
  
  	# second byte is '5'?
  	if (list_of_bytes[2] != 53):
  		return False
  	end
  
  	return True
  
  end
  
  def rq_set_var(var_name, var_value, gripper_socket="1"):
  
  	sync()
  	if (var_name == ACT):
  		socket_set_var("ACT", var_value, gripper_socket)
  	elif (var_name == GTO):
  		socket_set_var("GTO", var_value, gripper_socket)
  	elif (var_name == ATR):
  		socket_set_var("ATR", var_value, gripper_socket)
  	elif (var_name == ARD):
  		socket_set_var("ARD", var_value, gripper_socket)
  	elif (var_name == FOR):
  		socket_set_var("FOR", var_value, gripper_socket)
  	elif (var_name == SPE):
  		socket_set_var("SPE", var_value, gripper_socket)
  	elif (var_name == POS):
  		socket_set_var("POS", var_value, gripper_socket)
  	elif (var_name == LBP):
  		socket_set_var("LBP", var_value, gripper_socket)
  	elif (var_name == LRD):
  		socket_set_var("LRD", var_value, gripper_socket)
  	elif (var_name == LBL):
  		socket_set_var("LBL", var_value, gripper_socket)
  	elif (var_name == LGN):
  		socket_set_var("LGN", var_value, gripper_socket)
  	elif (var_name == MSC):
  		socket_set_var("MSC", var_value, gripper_socket)
  	else:
  	end
  
      sync()
  
  	ack = socket_read_byte_list(3, gripper_socket)
  
  	sync()
  
  	while(is_not_ack(ack)):
  		textmsg("Retry in rq_set_var")
  
  		textmsg("rq_set_var : retry", " ...")
  		textmsg("rq_set_var : var_name = ", var_name)
  		textmsg("rq_set_var : var_value = ", var_value)
  
  		if (ack[0] != 0):
  			textmsg("rq_set_var : invalid ack value = ", ack)
  		end
  
  		socket_set_var(var_name , var_value,gripper_socket)
  		sync()
  		ack = socket_read_byte_list(3, gripper_socket)
  		sync()
  	end
  end
  
  
  def rq_get_var(var_name, nbr_bytes, gripper_socket="1"):
  
  	if (var_name == FLT):
  		socket_send_string("GET FLT",gripper_socket)
  		sync()
  	elif (var_name == OBJ):
  		socket_send_string("GET OBJ",gripper_socket)
  		sync()
  	elif (var_name == STA):
  		socket_send_string("GET STA",gripper_socket)
  		sync()
  	elif (var_name == PRE):
  		socket_send_string("GET PRE",gripper_socket)
  		sync()
  	else:
  	end
  
  	var_value = socket_read_byte_list(nbr_bytes, gripper_socket)
  	sync()
  
  	return var_value
  end
  
  def rq_is_object_validated(gripper_selected, gripper_socket="1"):
  	if(gripper_selected):
  		if(rq_is_object_detected(gripper_socket)):
  		    return True
  		else:
  		    return False
  		end
  	else:
  		return True
  	end
  end
  
  ############################################
  # normalized functions (maps 0-100 to 0-255)
  ############################################
  def rq_set_force_norm(force_norm, gripper_socket="1"):
      force_gripper = norm_to_gripper(force_norm)
      rq_set_force(force_gripper, gripper_socket)
  end
  
  def rq_set_speed_norm(speed_norm, gripper_socket="1"):
      speed_gripper = norm_to_gripper(speed_norm)
      rq_set_speed(speed_gripper, gripper_socket)
  end
  
  def rq_move_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_set_pos_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_set_pos(pos_gripper, gripper_socket)
  end
  
  def rq_current_pos_norm(gripper_socket="1"):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_norm = gripper_to_norm(pos_gripper)
      return pos_norm
  end
  
  def gripper_to_norm(value_gripper):
      value_norm = (value_gripper / 255) * 100
      return floor(value_norm)
  end
  
  def norm_to_gripper(value_norm):
      value_gripper = (value_norm / 100) * 255
      return ceil(value_gripper)
  end
  
  def rq_get_position():
      return rq_current_pos_norm()
  end
  
  def rq_gripper_led_on(gripper_socket="1"):
      rq_set_var(LBP,0, gripper_socket)
  end
  
  def rq_gripper_led_off(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_red(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,1, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_blue(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,1, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_green(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,1, gripper_socket)
  end
  
  def rq_gripper_led_force_purple(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,1, gripper_socket)
      rq_set_var(LBL,1, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  ############################################
  # mm/inches functions
  ############################################
  gripper_closed_norm = [100, 100, 100, 100]
  gripper_open_norm = [0, 0, 0, 0]
  gripper_closed_mm = [0, 0, 0, 0]
  gripper_open_mm = [50, 50, 50, 50]
  
  def rq_current_pos_mm(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      return round_value_2_dec(pos_mm)
  end
  
  def rq_current_pos_inches(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      pos_in = pos_mm / 25.4
      return round_value_2_dec(pos_in)
  end
  
  def rq_move_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_move_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_mm(pos_mm, gripper_socket)
  end
  
  def rq_move_and_wait_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_and_wait_mm(pos_mm, gripper_socket)
  end
  
  def get_closed_norm(gripper_socket):
      return gripper_closed_norm[gripper_socket - 1]
  end
  
  def get_open_norm(gripper_socket):
      return gripper_open_norm[gripper_socket - 1]
  end
  
  def get_closed_mm(gripper_socket):
      return gripper_closed_mm[gripper_socket - 1]
  end
  
  def get_open_mm(gripper_socket):
      return gripper_open_mm[gripper_socket - 1]
  end
  
  def set_closed_norm(closed_norm, gripper_socket):
      gripper_closed_norm[gripper_socket - 1] = closed_norm
  end
  
  def set_open_norm(open_norm, gripper_socket):
      gripper_open_norm[gripper_socket - 1] = open_norm
  end
  
  def set_closed_mm(closed_mm, gripper_socket):
      gripper_closed_mm[gripper_socket - 1] = closed_mm
  end
  
  def set_open_mm(open_mm, gripper_socket):
      gripper_open_mm[gripper_socket - 1] = open_mm
  end
  
  def gripper_to_mm(value_gripper, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      value_norm = (value_gripper / 255) * 100
  
      slope = (closed_mm - open_mm) / (closed_norm - open_norm)
      value_mm = slope * (value_norm - closed_norm) + closed_mm
  
      if (value_mm > open_mm):
      	value_mm_limited = open_mm
      elif (value_mm < closed_mm):
      	value_mm_limited = closed_mm
      else:
          value_mm_limited = value_mm
      end
  
      return value_mm_limited
  end
  
  def mm_to_gripper(value_mm, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      slope = (closed_norm - open_norm) / (closed_mm - open_mm)
      value_norm = (value_mm - closed_mm) * slope + closed_norm
  
      value_gripper = value_norm * 255 / 100
  
      if (value_gripper > 255):
      	value_gripper_limited = 255
      elif (value_gripper < 0):
      	value_gripper_limited = 0
      else:
          value_gripper_limited = round_value(value_gripper)
      end
  
      return value_gripper_limited
  end
  
  def round_value(value):
      value_mod = value % 1
  
  	if(value_mod < 0.5):
  		return floor(value)
  	else:
  		return ceil(value)
  	end
  end
  
  def round_value_2_dec(value):
      value_x_100 = value * 100
      value_x_100_rounded = round_value(value_x_100)
      return value_x_100_rounded / 100
  end
  #########################################
  
  
  rq_obj_detect = 0
  rq_scan_block()
  rq_init_connection(9, "1")
  connectivity_checked = [-1,-1,-1,-1]
  status_checked = [-1,-1,-1,-1]
  current_speed = [-1,-1,-1,-1]
  current_force = [-1,-1,-1,-1]
  set_closed_norm(100.0,1)
  set_open_norm(0.0, 1)
  set_closed_mm(0.0, 1)
  set_open_mm(50.0, 1)
  set_closed_norm(100.0,2)
  set_open_norm(0.0, 2)
  set_closed_mm(0.0, 2)
  set_open_mm(50.0, 2)
  set_closed_norm(100.0,3)
  set_open_norm(0.0, 3)
  set_closed_mm(0.0, 3)
  set_open_mm(50.0, 3)
  set_closed_norm(100.0,4)
  set_open_norm(0.0, 4)
  set_closed_mm(0.0, 4)
  set_open_mm(50.0, 4)
  
  #######Gripper URCap preamble end##########
  ###########################################
  
  # end: URCap Installation Node
  $ 1 "BeforeStart"
  $ 2 "socketOpen≔socket_open('192.168.100.57',30002)"
  global socketOpen=socket_open("192.168.100.57",30002)
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
  #   Type: Gripper Activate
  $ 3 "Gripper Activate"
  
  reset_and_activate = False
  
  def rq_init_connection_and_status(gripper_sid=9, gripper_socket="1"):
  	socket_open("127.0.0.1",63352, gripper_socket)
  	socket_set_var("SID", gripper_sid,  gripper_socket)
  	ack = socket_read_byte_list(3, gripper_socket)
  	return is_ack(ack)
  end
  
  def rq_activate_if_connected(gripper_sid=9, gripper_socket="Activate1"):
      if(reset_and_activate):
          rq_reset(gripper_socket)
          sleep(0.1)
      end
  
      rq_activate_and_wait(gripper_socket)
  end
  
  if rq_init_connection_and_status(9, "Activate1"):
      rq_activate_if_connected(9, "Activate1")
  end
  
  if rq_init_connection_and_status(2, "Activate2"):
      rq_activate_if_connected(2, "Activate2")
  end
  
  if rq_init_connection_and_status(3, "Activate3"):
      rq_activate_if_connected(3, "Activate3")
  end
  
  if rq_init_connection_and_status(4, "Activate4"):
      rq_activate_if_connected(4, "Activate4")
  end
  
  socket_close("Activate1")
  socket_close("Activate2")
  socket_close("Activate3")
  socket_close("Activate4")
  
  sleep(0.1)
  # end: URCap Program Node
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
  #   Type: Gripper
  $ 4 "Gripper Move34% (1)"
  gripper_1_used = True
  if (connectivity_checked[0] != 1):
    if not(rq_set_sid(9, "1")):
      popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
    end
    connectivity_checked[0] = 1
  end
  if (status_checked[0] != 1):
    if not(rq_is_gripper_activated("1")):
      popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
    end
    status_checked[0] = 1
  end
  rq_set_speed(77, "1")
  current_speed[0] = 77
  rq_set_force(255, "1")
  current_force[0] = 255
  rq_set_pos(87, "1")
  rq_go_to("1")
  rq_wait("1")
  gripper_1_selected = True
  gripper_2_selected = False
  gripper_3_selected = False
  gripper_4_selected = False
  gripper_1_used = False
  gripper_2_used = False
  gripper_3_used = False
  gripper_4_used = False
  # end: URCap Program Node
  $ 5 "counter≔0"
  global counter=0
  $ 6 "lastTurnArray≔[0,0,0, 0,0,0, 0,0,0]"
  global lastTurnArray=[0,0,0, 0,0,0, 0,0,0]
  $ 7 "robotTurn≔0"
  global robotTurn=0
  $ 8 "gameMark≔2"
  global gameMark=2
  $ 9 "MoveJ"
  $ 10 "Waypoint_1"
  movej(get_inverse_kin(p[.100405069525, -.365279983977, .018698810103, -2.921178679328, .013981104861, -.034676824059], qnear=[-1.0929096380816858, -1.5755956808673304, -2.1668699423419397, -1.1556780974017542, 1.6884065866470337, 3.6124255657196045]), a=1.3962634015954636, v=1.0471975511965976)
  while (True):
    $ 11 "Robot Program"
    $ 13 "Loop socketOpen ≟  False "
    while (socketOpen  ==    False  ):
      $ 14 "socketOpen≔socket_open('192.168.100.57',30002)"
      global socketOpen=socket_open("192.168.100.57",30002)
      $ 15 "Wait: 0.5"
      sleep(0.5)
    end
    $ 16 "socket_send_string('sending_coordinates')"
    socket_send_string("sending_coordinates")
    $ 17 "Wait: 0.5"
    sleep(0.5)
    $ 18 "MoveJ"
    $ 19 "Waypoint_3"
    movej(get_inverse_kin(p[.100409504615, -.365248670578, .018686768540, -2.921054334328, .014153002967, -.034616776855], qnear=[-1.0928857962237757, -1.5756195227252405, -2.1668699423419397, -1.155773941670553, 1.6884424686431885, 3.6125571727752686]), a=1.3962634015954636, v=1.0471975511965976)
    # begin: URCap Program Node
    #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
    #   Type: Cam Locate
    $ 20 "Camera Locate"
    popup("Unable to initialize Vision Server. Go to Installation tab > Camera > Dashboard for more information.", warning = False, error = True)
    halt
    # end: URCap Program Node
    $ 41 "Wait: 0.1"
    sleep(0.1)
    $ 42 "socket_send_string('end')"
    socket_send_string("end")
    $ 43 "Wait: 0.1"
    sleep(0.1)
    $ 46 "gameMark≔-1"
    global gameMark=-1
    $ 47 "gameRunning≔0"
    global gameRunning=0
    $ 48 "Loop"
    while (True):
      $ 49 "Loop gameMark ≟ -1"
      while (gameMark  ==  -1):
        # begin: URCap Program Node
        #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
        #   Type: Cam Locate
        $ 50 "Camera Locate"
        
        ###########################################
        #######VisionLocate node start########
        
        # Offset in translation only.
        snapshot_position_offset[3] = 0
        snapshot_position_offset[4] = 0
        snapshot_position_offset[5] = 0
        T_camera_in_flange = p[0, 0, 0, 0, 0, 0] # enlever une fois que l'enseignement du modele sera fait en faisant un movetool avec la pose de la camera dans le repere de la flange. Pour l'instant, on suppose que la camera est situee directement sur la flange.
        tool_29391588 = get_T_in_base_from_flange(T_camera_in_flange)
        textmsg("actual tool flange : ", tool_29391588)
        tool_29391588 = pose_sub(tool_29391588, snapshot_position_offset)
        textmsg("tool after offset : ", tool_29391588)
        snapshot_position = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
        textmsg("expected snapshot position : ", snapshot_position)
        diff = pose_sub(tool_29391588, snapshot_position)
        textmsg("diff = ", diff)
        textmsg("norm([diff[0], diff[1], diff[2]]) = ", norm([diff[0], diff[1], diff[2]]))
        textmsg("norm([diff[3], diff[4], diff[5]]) = ", norm([diff[3], diff[4], diff[5]]))
        is_at_snapshot_position = norm([diff[0], diff[1], diff[2]]) < 0.002
        textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
        is_at_snapshot_position = is_at_snapshot_position and (norm([diff[3], diff[4], diff[5]]) < 0.005)
        textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
        is_snapshot_position_offset = norm(snapshot_position_offset) != 0
        is_at_snapshot_position = is_at_snapshot_position or ignore_snapshot_position
        if not(is_at_snapshot_position):
          popup("Robot is not at Snapshot Position. Add Move instruction to Snapshot Position before Camera Locate node.. Error code: [UCC-8]", warning = False, error = True)
          halt
        end
        f=[0,0.0,0.0,0.0,0.0,0.0,0.0,0]
        object_location=p[0.0,0.0,0.0,0.0,0.0,0.0]
        f_29391588 = xmlrpc_server.findmodel("contextName-4636", tool_29391588[0], tool_29391588[1], tool_29391588[2], tool_29391588[3], tool_29391588[4], tool_29391588[5])
        logging_service.publish("FIND_MODEL", f_29391588)
        nb_occurence_29391588 = f_29391588[0]
        i_29391588 = 0
        object_teaching_location = p[0.23218612247570997, -0.5716907056724064, -0.2620112149301531, 3.1373598399318476, -0.027121133892624803, -0.011352476919359826]
        feature_teaching_location = p[-0.0029355586540198465, -0.6845106766845338, -0.011173065082859784, 0.07743838940405703, 3.0061439383605966, -0.6671454616822479]
        # begin: URCap Program Node
        #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
        #   Type: Cam Locate Loop
        $ 51 "For object(s) found"
        while (i_29391588 < nb_occurence_29391588):
          current_object_location_29391588 = p[f_29391588[8*i_29391588+1],f_29391588[8*i_29391588+2],f_29391588[8*i_29391588+3],f_29391588[8*i_29391588+4],f_29391588[8*i_29391588+5],f_29391588[8*i_29391588+6]]
          object_location = current_object_location_29391588
          f[0] = f_29391588[0]
          f[1] = f_29391588[8*i_29391588+1]
          f[2] = f_29391588[8*i_29391588+2]
          f[3] = f_29391588[8*i_29391588+3]
          f[4] = f_29391588[8*i_29391588+4]
          f[5] = f_29391588[8*i_29391588+5]
          f[6] = f_29391588[8*i_29391588+6]
          f[7] = f_29391588[8*i_29391588+7]
          textmsg("current_object_location before offset = ", current_object_location_29391588)
          current_object_location_29391588 = pose_add(current_object_location_29391588, snapshot_position_offset)
          textmsg("current_object_location after offset = ", current_object_location_29391588)
          ruudukko2_OrJa = pose_trans(current_object_location_29391588, pose_trans(pose_inv(object_teaching_location), feature_teaching_location))
          $ 52 "mark≔1"
          global mark=1
          $ 53 "alotusChip_OrJa_var≔ruudukko2_OrJa_var"
          global alotusChip_OrJa=ruudukko2_OrJa
          $ 54 "alotuspalikka≔ruudukko2_OrJa_var"
          global alotuspalikka=ruudukko2_OrJa
          $ 55 "Script: valitseNappula_OrJa.script"
          	locatedX = object_location[0] #ruudukko2_OrJa_var[0]
          	locatedY = object_location[1] #ruudukko2_OrJa_var[1]
          
          	tempDist = 158/1000
          	tempSize = 70/1000
          
          	#tempDist2 = 120
          	textmsg(locatedX)
          	textmsg(locatedY)
          	textmsg(middleX)
          	textmsg(middleY)
          	textmsg(gameMark)
          	#if (locatedX > middleX + tempDist2):
          	# X
          	if ((locatedX > (middleX + tempDist - tempSize / 2)) and locatedX < ((middleX + tempDist + tempSize / 2))):
          		textmsg("asd")
          		# Y
          		if ((locatedY > (middleY - tempSize / 2)) and (locatedY < (middleY + tempSize / 2))):
          			gameMark = mark
          			gameRunning = 1
          			#alotusChip_OrJa = alotuspalikka
          			read = "asd"
          			while read != "send_starter":
          				sleep(1)
          				read = socket_read_string()
          			end
          
          			if gameMark == 1:
          				socket_send_string("1")
          				robotTurn = 1
          			elif gameMark == 2:
          				socket_send_string("0")
          			end
          		end
          	end
          i_29391588 = i_29391588 + 1
        end
        # end: URCap Program Node
        # Restore snapshot position
        ruudukko2_OrJa = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
        
        #######VisionLocate node end########
        ###########################################
        
        # end: URCap Program Node
        # begin: URCap Program Node
        #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
        #   Type: Cam Locate
        $ 56 "Camera Locate"
        
        ###########################################
        #######VisionLocate node start########
        
        # Offset in translation only.
        snapshot_position_offset[3] = 0
        snapshot_position_offset[4] = 0
        snapshot_position_offset[5] = 0
        T_camera_in_flange = p[0, 0, 0, 0, 0, 0] # enlever une fois que l'enseignement du modele sera fait en faisant un movetool avec la pose de la camera dans le repere de la flange. Pour l'instant, on suppose que la camera est situee directement sur la flange.
        tool_22622946 = get_T_in_base_from_flange(T_camera_in_flange)
        textmsg("actual tool flange : ", tool_22622946)
        tool_22622946 = pose_sub(tool_22622946, snapshot_position_offset)
        textmsg("tool after offset : ", tool_22622946)
        snapshot_position = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
        textmsg("expected snapshot position : ", snapshot_position)
        diff = pose_sub(tool_22622946, snapshot_position)
        textmsg("diff = ", diff)
        textmsg("norm([diff[0], diff[1], diff[2]]) = ", norm([diff[0], diff[1], diff[2]]))
        textmsg("norm([diff[3], diff[4], diff[5]]) = ", norm([diff[3], diff[4], diff[5]]))
        is_at_snapshot_position = norm([diff[0], diff[1], diff[2]]) < 0.002
        textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
        is_at_snapshot_position = is_at_snapshot_position and (norm([diff[3], diff[4], diff[5]]) < 0.005)
        textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
        is_snapshot_position_offset = norm(snapshot_position_offset) != 0
        is_at_snapshot_position = is_at_snapshot_position or ignore_snapshot_position
        if not(is_at_snapshot_position):
          popup("Robot is not at Snapshot Position. Add Move instruction to Snapshot Position before Camera Locate node.. Error code: [UCC-8]", warning = False, error = True)
          halt
        end
        f=[0,0.0,0.0,0.0,0.0,0.0,0.0,0]
        object_location=p[0.0,0.0,0.0,0.0,0.0,0.0]
        f_22622946 = xmlrpc_server.findmodel("contextName-64222", tool_22622946[0], tool_22622946[1], tool_22622946[2], tool_22622946[3], tool_22622946[4], tool_22622946[5])
        logging_service.publish("FIND_MODEL", f_22622946)
        nb_occurence_22622946 = f_22622946[0]
        i_22622946 = 0
        object_teaching_location = p[0.10412236926434586, -0.49129394831916007, -0.27414414118091, 3.1373598399319036, -0.02712113389239758, -0.011352476919359115]
        feature_teaching_location = p[-0.0029355586540198465, -0.6845106766845338, -0.011173065082859784, 0.07743838940405703, 3.0061439383605966, -0.6671454616822479]
        # begin: URCap Program Node
        #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
        #   Type: Cam Locate Loop
        $ 57 "For object(s) found"
        while (i_22622946 < nb_occurence_22622946):
          current_object_location_22622946 = p[f_22622946[8*i_22622946+1],f_22622946[8*i_22622946+2],f_22622946[8*i_22622946+3],f_22622946[8*i_22622946+4],f_22622946[8*i_22622946+5],f_22622946[8*i_22622946+6]]
          object_location = current_object_location_22622946
          f[0] = f_22622946[0]
          f[1] = f_22622946[8*i_22622946+1]
          f[2] = f_22622946[8*i_22622946+2]
          f[3] = f_22622946[8*i_22622946+3]
          f[4] = f_22622946[8*i_22622946+4]
          f[5] = f_22622946[8*i_22622946+5]
          f[6] = f_22622946[8*i_22622946+6]
          f[7] = f_22622946[8*i_22622946+7]
          textmsg("current_object_location before offset = ", current_object_location_22622946)
          current_object_location_22622946 = pose_add(current_object_location_22622946, snapshot_position_offset)
          textmsg("current_object_location after offset = ", current_object_location_22622946)
          ruudukko2_OrJa = pose_trans(current_object_location_22622946, pose_trans(pose_inv(object_teaching_location), feature_teaching_location))
          $ 58 "mark≔2"
          global mark=2
          $ 59 "alotusChip_OrJa_var≔ruudukko2_OrJa_var"
          global alotusChip_OrJa=ruudukko2_OrJa
          $ 60 "alotuspalikka≔ruudukko2_OrJa_var"
          global alotuspalikka=ruudukko2_OrJa
          $ 61 "Script: valitseNappula_OrJa.script"
          	locatedX = object_location[0] #ruudukko2_OrJa_var[0]
          	locatedY = object_location[1] #ruudukko2_OrJa_var[1]
          
          	tempDist = 158/1000
          	tempSize = 70/1000
          
          	#tempDist2 = 120
          	textmsg(locatedX)
          	textmsg(locatedY)
          	textmsg(middleX)
          	textmsg(middleY)
          	textmsg(gameMark)
          	#if (locatedX > middleX + tempDist2):
          	# X
          	if ((locatedX > (middleX + tempDist - tempSize / 2)) and locatedX < ((middleX + tempDist + tempSize / 2))):
          		textmsg("asd")
          		# Y
          		if ((locatedY > (middleY - tempSize / 2)) and (locatedY < (middleY + tempSize / 2))):
          			gameMark = mark
          			gameRunning = 1
          			#alotusChip_OrJa = alotuspalikka
          			read = "asd"
          			while read != "send_starter":
          				sleep(1)
          				read = socket_read_string()
          			end
          
          			if gameMark == 1:
          				socket_send_string("1")
          				robotTurn = 1
          			elif gameMark == 2:
          				socket_send_string("0")
          			end
          		end
          	end
          i_22622946 = i_22622946 + 1
        end
        # end: URCap Program Node
        # Restore snapshot position
        ruudukko2_OrJa = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
        
        #######VisionLocate node end########
        ###########################################
        
        # end: URCap Program Node
      end
      $ 62 "Loop gameRunning ≟ 1"
      while (gameRunning  ==  1):
        $ 63 "textmsg(robotTurn)"
        textmsg(robotTurn)
        $ 64 "read≔socket_read_string()"
        global read=socket_read_string()
        $ 65 "If read≟'mark_cell'"
        global thread_flag_65=0
        thread Thread_if_65():
          $ 67 "socket_send_string('oke')"
          socket_send_string("oke")
          $ 69 "Loop robotTurn≟1"
          while (robotTurn == 1):
            $ 70 "textmsg(robotTurn)"
            textmsg(robotTurn)
            $ 71 "Wait: 1.0"
            sleep(1.0)
            $ 72 "textmsg(robotTurn)"
            textmsg(robotTurn)
            $ 73 "socket_send_string('ready_for_data')"
            socket_send_string("ready_for_data")
            $ 74 "Wait: 1.0"
            sleep(1.0)
            $ 75 "position≔socket_read_ascii_float(3)"
            global position=socket_read_ascii_float(3)
            $ 76 "textmsg(position)"
            textmsg(position)
            $ 77 "If position[0]≠0"
            if (position[0] != 0):
              $ 78 "MoveL"
              $ 79 "Waypoint_2"
              movel(p[-.260810034832, -.315512195954, .021389182481, -2.980742885769, -.011900458321, .087590502420], a=1.2, v=0.25)
              $ 81 "If gameMark≟1"
              if (gameMark == 1):
                # begin: URCap Program Node
                #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
                #   Type: Cam Locate
                $ 82 "Camera Locate"
                
                ###########################################
                #######VisionLocate node start########
                
                # Offset in translation only.
                snapshot_position_offset[3] = 0
                snapshot_position_offset[4] = 0
                snapshot_position_offset[5] = 0
                T_camera_in_flange = p[0, 0, 0, 0, 0, 0] # enlever une fois que l'enseignement du modele sera fait en faisant un movetool avec la pose de la camera dans le repere de la flange. Pour l'instant, on suppose que la camera est situee directement sur la flange.
                tool_13571637 = get_T_in_base_from_flange(T_camera_in_flange)
                textmsg("actual tool flange : ", tool_13571637)
                tool_13571637 = pose_sub(tool_13571637, snapshot_position_offset)
                textmsg("tool after offset : ", tool_13571637)
                snapshot_position = p[-0.250175, -0.344039, 0.198793, -2.98084, -0.0118643, 0.0873949]
                textmsg("expected snapshot position : ", snapshot_position)
                diff = pose_sub(tool_13571637, snapshot_position)
                textmsg("diff = ", diff)
                textmsg("norm([diff[0], diff[1], diff[2]]) = ", norm([diff[0], diff[1], diff[2]]))
                textmsg("norm([diff[3], diff[4], diff[5]]) = ", norm([diff[3], diff[4], diff[5]]))
                is_at_snapshot_position = norm([diff[0], diff[1], diff[2]]) < 0.002
                textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
                is_at_snapshot_position = is_at_snapshot_position and (norm([diff[3], diff[4], diff[5]]) < 0.005)
                textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
                is_snapshot_position_offset = norm(snapshot_position_offset) != 0
                is_at_snapshot_position = is_at_snapshot_position or ignore_snapshot_position
                if not(is_at_snapshot_position):
                  popup("Robot is not at Snapshot Position. Add Move instruction to Snapshot Position before Camera Locate node.. Error code: [UCC-8]", warning = False, error = True)
                  halt
                end
                f=[0,0.0,0.0,0.0,0.0,0.0,0.0,0]
                object_location=p[0.0,0.0,0.0,0.0,0.0,0.0]
                f_13571637 = xmlrpc_server.findmodel("contextName-94060", tool_13571637[0], tool_13571637[1], tool_13571637[2], tool_13571637[3], tool_13571637[4], tool_13571637[5])
                logging_service.publish("FIND_MODEL", f_13571637)
                nb_occurence_13571637 = f_13571637[0]
                i_13571637 = 0
                object_teaching_location = p[-0.24103644728906207, -0.5181418876404739, -0.2708175837813739, 3.138882600301379, 0.025865206181421227, -0.010409494660059332]
                feature_teaching_location = p[-0.2607920425887187, -0.31551328938356726, 0.021374773672193675, -2.980799603239241, -0.011780808039767682, 0.08743075633525293]
                # begin: URCap Program Node
                #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
                #   Type: Cam Locate Loop
                $ 83 "For object(s) found"
                while (i_13571637 < nb_occurence_13571637):
                  current_object_location_13571637 = p[f_13571637[8*i_13571637+1],f_13571637[8*i_13571637+2],f_13571637[8*i_13571637+3],f_13571637[8*i_13571637+4],f_13571637[8*i_13571637+5],f_13571637[8*i_13571637+6]]
                  object_location = current_object_location_13571637
                  f[0] = f_13571637[0]
                  f[1] = f_13571637[8*i_13571637+1]
                  f[2] = f_13571637[8*i_13571637+2]
                  f[3] = f_13571637[8*i_13571637+3]
                  f[4] = f_13571637[8*i_13571637+4]
                  f[5] = f_13571637[8*i_13571637+5]
                  f[6] = f_13571637[8*i_13571637+6]
                  f[7] = f_13571637[8*i_13571637+7]
                  textmsg("current_object_location before offset = ", current_object_location_13571637)
                  current_object_location_13571637 = pose_add(current_object_location_13571637, snapshot_position_offset)
                  textmsg("current_object_location after offset = ", current_object_location_13571637)
                  nappulat_OrJa = pose_trans(current_object_location_13571637, pose_trans(pose_inv(object_teaching_location), feature_teaching_location))
                  $ 84 "MoveL"
                  $ 85 "Kohdistus_1"
                  movel(pose_trans(nappulat_OrJa, p[0.04019491185039978,0.23386103763917082,0.19595666052109853,-0.1278464396512843,0.04210008083625858,-0.035583285359297244]), a=1.2, v=0.25)
                  # begin: URCap Program Node
                  #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
                  #   Type: Gripper
                  $ 86 "Gripper Move34% (1)"
                  gripper_1_used = True
                  if (connectivity_checked[0] != 1):
                    if not(rq_set_sid(9, "1")):
                      popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
                    end
                    connectivity_checked[0] = 1
                  end
                  if (status_checked[0] != 1):
                    if not(rq_is_gripper_activated("1")):
                      popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
                    end
                    status_checked[0] = 1
                  end
                  rq_set_speed(77, "1")
                  current_speed[0] = 77
                  rq_set_force(255, "1")
                  current_force[0] = 255
                  rq_set_pos(87, "1")
                  rq_go_to("1")
                  rq_wait("1")
                  gripper_1_selected = True
                  gripper_2_selected = False
                  gripper_3_selected = False
                  gripper_4_selected = False
                  gripper_1_used = False
                  gripper_2_used = False
                  gripper_3_used = False
                  gripper_4_used = False
                  # end: URCap Program Node
                  $ 87 "MoveL"
                  $ 88 "Kiinniottokoh_1"
                  movel(pose_trans(nappulat_OrJa, p[0.042104420485943345,0.2390736490928263,0.22838989642569243,-0.12774454902266844,0.04213534202941864,-0.035536719762199]), a=1.2, v=0.25)
                  # begin: URCap Program Node
                  #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
                  #   Type: Gripper
                  $ 89 "Gripper Close (1)"
                  gripper_1_used = True
                  if (connectivity_checked[0] != 1):
                    if not(rq_set_sid(9, "1")):
                      popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
                    end
                    connectivity_checked[0] = 1
                  end
                  if (status_checked[0] != 1):
                    if not(rq_is_gripper_activated("1")):
                      popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
                    end
                    status_checked[0] = 1
                  end
                  rq_set_speed(77, "1")
                  current_speed[0] = 77
                  rq_set_force(255, "1")
                  current_force[0] = 255
                  rq_set_pos(255, "1")
                  rq_go_to("1")
                  rq_wait("1")
                  gripper_1_selected = True
                  gripper_2_selected = False
                  gripper_3_selected = False
                  gripper_4_selected = False
                  gripper_1_used = False
                  gripper_2_used = False
                  gripper_3_used = False
                  gripper_4_used = False
                  # end: URCap Program Node
                  $ 90 "NostaHiemanYl_1"
                  movel(pose_trans(nappulat_OrJa, p[0.04018532333046468,0.23388398165999796,0.19594268027340478,-0.1278830158799261,0.042055201249211666,-0.035553991656031264]), a=1.2, v=0.25)
                  i_13571637 = i_13571637 + 1
                end
                # end: URCap Program Node
                # Restore snapshot position
                nappulat_OrJa = p[-0.250175, -0.344039, 0.198793, -2.98084, -0.0118643, 0.0873949]
                
                #######VisionLocate node end########
                ###########################################
                
                # end: URCap Program Node
              else:
                $ 91 "Else"
                # begin: URCap Program Node
                #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
                #   Type: Cam Locate
                $ 92 "Camera Locate"
                
                ###########################################
                #######VisionLocate node start########
                
                # Offset in translation only.
                snapshot_position_offset[3] = 0
                snapshot_position_offset[4] = 0
                snapshot_position_offset[5] = 0
                T_camera_in_flange = p[0, 0, 0, 0, 0, 0] # enlever une fois que l'enseignement du modele sera fait en faisant un movetool avec la pose de la camera dans le repere de la flange. Pour l'instant, on suppose que la camera est situee directement sur la flange.
                tool_18127359 = get_T_in_base_from_flange(T_camera_in_flange)
                textmsg("actual tool flange : ", tool_18127359)
                tool_18127359 = pose_sub(tool_18127359, snapshot_position_offset)
                textmsg("tool after offset : ", tool_18127359)
                snapshot_position = p[-0.250175, -0.344039, 0.198793, -2.98084, -0.0118643, 0.0873949]
                textmsg("expected snapshot position : ", snapshot_position)
                diff = pose_sub(tool_18127359, snapshot_position)
                textmsg("diff = ", diff)
                textmsg("norm([diff[0], diff[1], diff[2]]) = ", norm([diff[0], diff[1], diff[2]]))
                textmsg("norm([diff[3], diff[4], diff[5]]) = ", norm([diff[3], diff[4], diff[5]]))
                is_at_snapshot_position = norm([diff[0], diff[1], diff[2]]) < 0.002
                textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
                is_at_snapshot_position = is_at_snapshot_position and (norm([diff[3], diff[4], diff[5]]) < 0.005)
                textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
                is_snapshot_position_offset = norm(snapshot_position_offset) != 0
                is_at_snapshot_position = is_at_snapshot_position or ignore_snapshot_position
                if not(is_at_snapshot_position):
                  popup("Robot is not at Snapshot Position. Add Move instruction to Snapshot Position before Camera Locate node.. Error code: [UCC-8]", warning = False, error = True)
                  halt
                end
                f=[0,0.0,0.0,0.0,0.0,0.0,0.0,0]
                object_location=p[0.0,0.0,0.0,0.0,0.0,0.0]
                f_18127359 = xmlrpc_server.findmodel("contextName-1181", tool_18127359[0], tool_18127359[1], tool_18127359[2], tool_18127359[3], tool_18127359[4], tool_18127359[5])
                logging_service.publish("FIND_MODEL", f_18127359)
                nb_occurence_18127359 = f_18127359[0]
                i_18127359 = 0
                object_teaching_location = p[-0.28683227132456396, -0.5376864337796667, -0.2679093248734872, 3.138882600301678, 0.025865206146659582, -0.010409494660060725]
                feature_teaching_location = p[-0.2607920425887187, -0.31551328938356726, 0.021374773672193675, -2.980799603239241, -0.011780808039767682, 0.08743075633525293]
                # begin: URCap Program Node
                #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
                #   Type: Cam Locate Loop
                $ 93 "For object(s) found"
                while (i_18127359 < nb_occurence_18127359):
                  current_object_location_18127359 = p[f_18127359[8*i_18127359+1],f_18127359[8*i_18127359+2],f_18127359[8*i_18127359+3],f_18127359[8*i_18127359+4],f_18127359[8*i_18127359+5],f_18127359[8*i_18127359+6]]
                  object_location = current_object_location_18127359
                  f[0] = f_18127359[0]
                  f[1] = f_18127359[8*i_18127359+1]
                  f[2] = f_18127359[8*i_18127359+2]
                  f[3] = f_18127359[8*i_18127359+3]
                  f[4] = f_18127359[8*i_18127359+4]
                  f[5] = f_18127359[8*i_18127359+5]
                  f[6] = f_18127359[8*i_18127359+6]
                  f[7] = f_18127359[8*i_18127359+7]
                  textmsg("current_object_location before offset = ", current_object_location_18127359)
                  current_object_location_18127359 = pose_add(current_object_location_18127359, snapshot_position_offset)
                  textmsg("current_object_location after offset = ", current_object_location_18127359)
                  nappulat_OrJa = pose_trans(current_object_location_18127359, pose_trans(pose_inv(object_teaching_location), feature_teaching_location))
                  $ 94 "MoveL"
                  $ 95 "Kohdistus"
                  movel(pose_trans(nappulat_OrJa, p[-0.00829396816767769,0.24862437762031536,0.17647082764627986,-0.13375863938865096,0.07406828280348125,0.07699749298269486]), a=1.2, v=0.25)
                  # begin: URCap Program Node
                  #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
                  #   Type: Gripper
                  $ 96 "Gripper Move34% (1)"
                  gripper_1_used = True
                  if (connectivity_checked[0] != 1):
                    if not(rq_set_sid(9, "1")):
                      popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
                    end
                    connectivity_checked[0] = 1
                  end
                  if (status_checked[0] != 1):
                    if not(rq_is_gripper_activated("1")):
                      popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
                    end
                    status_checked[0] = 1
                  end
                  rq_set_speed(77, "1")
                  current_speed[0] = 77
                  rq_set_force(255, "1")
                  current_force[0] = 255
                  rq_set_pos(87, "1")
                  rq_go_to("1")
                  rq_wait("1")
                  gripper_1_selected = True
                  gripper_2_selected = False
                  gripper_3_selected = False
                  gripper_4_selected = False
                  gripper_1_used = False
                  gripper_2_used = False
                  gripper_3_used = False
                  gripper_4_used = False
                  # end: URCap Program Node
                  $ 97 "MoveL"
                  $ 98 "Kiinniottokohta"
                  movel(pose_trans(nappulat_OrJa, p[-0.005349186569852726,0.2568412529337177,0.2271544003313269,-0.1338541904856596,0.07411644386988,0.07700287996185869]), a=1.2, v=0.25)
                  # begin: URCap Program Node
                  #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
                  #   Type: Gripper
                  $ 99 "Gripper Close (1)"
                  gripper_1_used = True
                  if (connectivity_checked[0] != 1):
                    if not(rq_set_sid(9, "1")):
                      popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
                    end
                    connectivity_checked[0] = 1
                  end
                  if (status_checked[0] != 1):
                    if not(rq_is_gripper_activated("1")):
                      popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
                    end
                    status_checked[0] = 1
                  end
                  rq_set_speed(77, "1")
                  current_speed[0] = 77
                  rq_set_force(255, "1")
                  current_force[0] = 255
                  rq_set_pos(255, "1")
                  rq_go_to("1")
                  rq_wait("1")
                  gripper_1_selected = True
                  gripper_2_selected = False
                  gripper_3_selected = False
                  gripper_4_selected = False
                  gripper_1_used = False
                  gripper_2_used = False
                  gripper_3_used = False
                  gripper_4_used = False
                  # end: URCap Program Node
                  $ 100 "NostaHiemanYlos"
                  movel(pose_trans(nappulat_OrJa, p[-0.008285622037412066,0.24859707010355264,0.17647719451607224,-0.13371883338392943,0.07410503136865954,0.07700564647419168]), a=1.2, v=0.25)
                  i_18127359 = i_18127359 + 1
                end
                # end: URCap Program Node
                # Restore snapshot position
                nappulat_OrJa = p[-0.250175, -0.344039, 0.198793, -2.98084, -0.0118643, 0.0873949]
                
                #######VisionLocate node end########
                ###########################################
                
                # end: URCap Program Node
              end
              $ 101 "var_1≔p[position[1], position[2], calibLoc[2], calibLoc[3], calibLoc[4], calibLoc[5]]"
              global var_1=p[position[1], position[2], calibLoc[2], calibLoc[3], calibLoc[4], calibLoc[5]]
              $ 102 "textmsg(var_1)"
              textmsg(var_1)
              $ 104 "target2≔pose_trans(keskipiste, pose_sub(calibLoc , var_1))"
              global target2=pose_trans(keskipiste, pose_sub(calibLoc , var_1))
              $ 105 "vienti≔pose_trans(target2, p[0, 0, -0.05, 0, 0, 0])"
              global vienti=pose_trans(target2, p[0, 0, -0.05, 0, 0, 0])
              $ 106 "MoveL"
              $ 107 "vienti"
              movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], vienti), a=1.2, v=0.25)
              $ 108 "target2"
              movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], target2), a=1.2, v=0.25)
              # begin: URCap Program Node
              #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
              #   Type: Gripper
              $ 109 "Gripper Move34% (1)"
              gripper_1_used = True
              if (connectivity_checked[0] != 1):
                if not(rq_set_sid(9, "1")):
                  popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
                end
                connectivity_checked[0] = 1
              end
              if (status_checked[0] != 1):
                if not(rq_is_gripper_activated("1")):
                  popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
                end
                status_checked[0] = 1
              end
              rq_set_speed(77, "1")
              current_speed[0] = 77
              rq_set_force(255, "1")
              current_force[0] = 255
              rq_set_pos(87, "1")
              rq_go_to("1")
              rq_wait("1")
              gripper_1_selected = True
              gripper_2_selected = False
              gripper_3_selected = False
              gripper_4_selected = False
              gripper_1_used = False
              gripper_2_used = False
              gripper_3_used = False
              gripper_4_used = False
              # end: URCap Program Node
              $ 110 "vienti"
              movel(pose_trans(p[0.0,0.0,0.0,0.0,0.0,0.0], vienti), a=1.2, v=0.25)
              $ 111 "textmsg(keskipiste)"
              textmsg(keskipiste)
              $ 112 "textmsg(calibFeature_var)"
              textmsg(calibFeature)
              $ 114 "MoveJ"
              $ 115 "Waypoint_3"
              movej(get_inverse_kin(p[.100409504615, -.365248670578, .018686768540, -2.921054334328, .014153002967, -.034616776855], qnear=[-1.0928857962237757, -1.5756195227252405, -2.1668699423419397, -1.155773941670553, 1.6884424686431885, 3.6125571727752686]), a=1.3962634015954636, v=1.0471975511965976)
              $ 116 "lastTurnArray[position[3]] = gameMark"
              lastTurnArray[position[3]] = gameMark
              $ 117 "counter≔counter + 1"
              global counter=counter + 1
              $ 118 "robotTurn≔0"
              global robotTurn=0
            end
          end
          thread_flag_65 = 1
        end
        if (read == "mark_cell"):
          global thread_handler_65=run Thread_if_65()
          while (thread_flag_65 == 0):
            if not(read == "mark_cell"):
              kill thread_handler_65
              thread_flag_65 = 2
            else:
              sync()
            end
          end
        else:
          thread_flag_65 = 2
        end
        if (thread_flag_65 == 2):
          $ 119 "ElseIf read ≟'player_turn'"
          if (read  == "player_turn"):
            $ 120 "read≔''"
            global read=""
            $ 121 "arrayChanged≔0"
            global arrayChanged=0
            $ 122 "tempArray2≔[0,0,0, 0,0,0, 0,0,0]"
            global tempArray2=[0,0,0, 0,0,0, 0,0,0]
            $ 123 "socket_send_string('oke')"
            socket_send_string("oke")
            $ 124 "Loop arrayChanged≟0"
            while (arrayChanged == 0):
              $ 125 "tempArray≔[0,0,0, 0,0,0, 0,0,0]"
              global tempArray=[0,0,0, 0,0,0, 0,0,0]
              $ 126 "tempCounter≔0"
              global tempCounter=0
              # begin: URCap Program Node
              #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
              #   Type: Cam Locate
              $ 127 "Camera Locate"
              
              ###########################################
              #######VisionLocate node start########
              
              # Offset in translation only.
              snapshot_position_offset[3] = 0
              snapshot_position_offset[4] = 0
              snapshot_position_offset[5] = 0
              T_camera_in_flange = p[0, 0, 0, 0, 0, 0] # enlever une fois que l'enseignement du modele sera fait en faisant un movetool avec la pose de la camera dans le repere de la flange. Pour l'instant, on suppose que la camera est situee directement sur la flange.
              tool_18028343 = get_T_in_base_from_flange(T_camera_in_flange)
              textmsg("actual tool flange : ", tool_18028343)
              tool_18028343 = pose_sub(tool_18028343, snapshot_position_offset)
              textmsg("tool after offset : ", tool_18028343)
              snapshot_position = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
              textmsg("expected snapshot position : ", snapshot_position)
              diff = pose_sub(tool_18028343, snapshot_position)
              textmsg("diff = ", diff)
              textmsg("norm([diff[0], diff[1], diff[2]]) = ", norm([diff[0], diff[1], diff[2]]))
              textmsg("norm([diff[3], diff[4], diff[5]]) = ", norm([diff[3], diff[4], diff[5]]))
              is_at_snapshot_position = norm([diff[0], diff[1], diff[2]]) < 0.002
              textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
              is_at_snapshot_position = is_at_snapshot_position and (norm([diff[3], diff[4], diff[5]]) < 0.005)
              textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
              is_snapshot_position_offset = norm(snapshot_position_offset) != 0
              is_at_snapshot_position = is_at_snapshot_position or ignore_snapshot_position
              if not(is_at_snapshot_position):
                popup("Robot is not at Snapshot Position. Add Move instruction to Snapshot Position before Camera Locate node.. Error code: [UCC-8]", warning = False, error = True)
                halt
              end
              f=[0,0.0,0.0,0.0,0.0,0.0,0.0,0]
              object_location=p[0.0,0.0,0.0,0.0,0.0,0.0]
              f_18028343 = xmlrpc_server.findmodel("contextName-7148", tool_18028343[0], tool_18028343[1], tool_18028343[2], tool_18028343[3], tool_18028343[4], tool_18028343[5])
              logging_service.publish("FIND_MODEL", f_18028343)
              nb_occurence_18028343 = f_18028343[0]
              i_18028343 = 0
              object_teaching_location = p[0.23218612247570997, -0.5716907056724064, -0.2620112149301531, 3.1373598399318476, -0.027121133892624803, -0.011352476919359826]
              feature_teaching_location = p[-0.0029355586540198465, -0.6845106766845338, -0.011173065082859784, 0.07743838940405703, 3.0061439383605966, -0.6671454616822479]
              # begin: URCap Program Node
              #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
              #   Type: Cam Locate Loop
              $ 128 "For object(s) found"
              while (i_18028343 < nb_occurence_18028343):
                current_object_location_18028343 = p[f_18028343[8*i_18028343+1],f_18028343[8*i_18028343+2],f_18028343[8*i_18028343+3],f_18028343[8*i_18028343+4],f_18028343[8*i_18028343+5],f_18028343[8*i_18028343+6]]
                object_location = current_object_location_18028343
                f[0] = f_18028343[0]
                f[1] = f_18028343[8*i_18028343+1]
                f[2] = f_18028343[8*i_18028343+2]
                f[3] = f_18028343[8*i_18028343+3]
                f[4] = f_18028343[8*i_18028343+4]
                f[5] = f_18028343[8*i_18028343+5]
                f[6] = f_18028343[8*i_18028343+6]
                f[7] = f_18028343[8*i_18028343+7]
                textmsg("current_object_location before offset = ", current_object_location_18028343)
                current_object_location_18028343 = pose_add(current_object_location_18028343, snapshot_position_offset)
                textmsg("current_object_location after offset = ", current_object_location_18028343)
                ruudukko2_OrJa = pose_trans(current_object_location_18028343, pose_trans(pose_inv(object_teaching_location), feature_teaching_location))
                $ 129 "foundGameMark≔1"
                global foundGameMark=1
                $ 130 "loc≔object_location"
                global loc=object_location
                $ 132 "Script: etsiRuutu_OrJa.script"
                	locatedX = loc[0]
                	locatedY = loc[1]
                
                
                	tempCounter = tempCounter + 1
                	dist = 71/1000
                	pos = -1
                
                	textmsg("sijainti, keskipiste")
                	textmsg(locatedX)
                	#textmsg(locatedX, " ", locatedY)
                	textmsg(locatedY)
                	#textmsg(locatedY)
                
                	#textmsg(middleX)
                	textmsg(middleX)
                	textmsg(middleY)
                	#textmsg(middleY)
                
                	if locatedX < (middleX - dist / 2):
                		# x--
                		# x--
                		# x--
                
                		if locatedY > (middleY + dist / 2):
                			# x--
                			# ---
                			# ---
                			pos = 0
                
                		elif locatedY < (middleY - dist / 2):
                			# ---
                			# ---
                			# x--
                			pos = 6
                
                		else:
                			# ---
                			# x--
                			# ---
                			pos = 3
                		end
                
                	# game markin valintaa varten hakualuetta rajataan tarkemmin
                	elif ((locatedX > (middleX + dist / 2)) and (locatedX < (middleX + dist * 1.5))):
                		# --x
                		# --x
                		# --x
                
                		if locatedY > (middleY + dist / 2):
                			# --x
                			# ---
                			# ---
                			pos = 2
                
                		elif locatedY < (middleY - dist / 2):
                			# ---
                			# ---
                			# --x
                			pos = 8
                
                		else:
                			# ---
                			# --x
                			# ---
                			pos = 5
                		end
                
                	#else:
                	elif ((locatedX > middleX - dist / 2) and (locatedX < middleX + dist / 2)):
                		# -x-
                		# -x-
                		# -x-
                
                		if locatedY > (middleY + dist / 2):
                			# -x-
                			# ---
                			# ---
                			pos = 1
                
                		elif locatedY < (middleY - dist / 2):
                			# ---
                			# ---
                			# -x-
                			pos = 7
                
                		#else:
                		elif ((locatedY > middleY - dist / 2) and (locatedY < middleY + dist / 2)):
                			# ---
                			# -x-
                			# ---
                			pos = 4
                		end
                	end
                
                	if pos != -1:
                		tempArray[pos] = foundGameMark
                	else:
                		#popup("Jokin meni pieleen")
                		textmsg("ei ruudukossa")
                	end
                i_18028343 = i_18028343 + 1
              end
              # end: URCap Program Node
              # Restore snapshot position
              ruudukko2_OrJa = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
              
              #######VisionLocate node end########
              ###########################################
              
              # end: URCap Program Node
              # begin: URCap Program Node
              #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
              #   Type: Cam Locate
              $ 133 "Camera Locate"
              
              ###########################################
              #######VisionLocate node start########
              
              # Offset in translation only.
              snapshot_position_offset[3] = 0
              snapshot_position_offset[4] = 0
              snapshot_position_offset[5] = 0
              T_camera_in_flange = p[0, 0, 0, 0, 0, 0] # enlever une fois que l'enseignement du modele sera fait en faisant un movetool avec la pose de la camera dans le repere de la flange. Pour l'instant, on suppose que la camera est situee directement sur la flange.
              tool_14087731 = get_T_in_base_from_flange(T_camera_in_flange)
              textmsg("actual tool flange : ", tool_14087731)
              tool_14087731 = pose_sub(tool_14087731, snapshot_position_offset)
              textmsg("tool after offset : ", tool_14087731)
              snapshot_position = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
              textmsg("expected snapshot position : ", snapshot_position)
              diff = pose_sub(tool_14087731, snapshot_position)
              textmsg("diff = ", diff)
              textmsg("norm([diff[0], diff[1], diff[2]]) = ", norm([diff[0], diff[1], diff[2]]))
              textmsg("norm([diff[3], diff[4], diff[5]]) = ", norm([diff[3], diff[4], diff[5]]))
              is_at_snapshot_position = norm([diff[0], diff[1], diff[2]]) < 0.002
              textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
              is_at_snapshot_position = is_at_snapshot_position and (norm([diff[3], diff[4], diff[5]]) < 0.005)
              textmsg("is_at_snapshot_position = ", is_at_snapshot_position)
              is_snapshot_position_offset = norm(snapshot_position_offset) != 0
              is_at_snapshot_position = is_at_snapshot_position or ignore_snapshot_position
              if not(is_at_snapshot_position):
                popup("Robot is not at Snapshot Position. Add Move instruction to Snapshot Position before Camera Locate node.. Error code: [UCC-8]", warning = False, error = True)
                halt
              end
              f=[0,0.0,0.0,0.0,0.0,0.0,0.0,0]
              object_location=p[0.0,0.0,0.0,0.0,0.0,0.0]
              f_14087731 = xmlrpc_server.findmodel("contextName-20897", tool_14087731[0], tool_14087731[1], tool_14087731[2], tool_14087731[3], tool_14087731[4], tool_14087731[5])
              logging_service.publish("FIND_MODEL", f_14087731)
              nb_occurence_14087731 = f_14087731[0]
              i_14087731 = 0
              object_teaching_location = p[0.10412236926434586, -0.49129394831916007, -0.27414414118091, 3.1373598399319036, -0.02712113389239758, -0.011352476919359115]
              feature_teaching_location = p[-0.0029355586540198465, -0.6845106766845338, -0.011173065082859784, 0.07743838940405703, 3.0061439383605966, -0.6671454616822479]
              # begin: URCap Program Node
              #   Source: Robotiq_Wrist_Camera, 1.6.6, Robotiq Inc.
              #   Type: Cam Locate Loop
              $ 134 "For object(s) found"
              while (i_14087731 < nb_occurence_14087731):
                current_object_location_14087731 = p[f_14087731[8*i_14087731+1],f_14087731[8*i_14087731+2],f_14087731[8*i_14087731+3],f_14087731[8*i_14087731+4],f_14087731[8*i_14087731+5],f_14087731[8*i_14087731+6]]
                object_location = current_object_location_14087731
                f[0] = f_14087731[0]
                f[1] = f_14087731[8*i_14087731+1]
                f[2] = f_14087731[8*i_14087731+2]
                f[3] = f_14087731[8*i_14087731+3]
                f[4] = f_14087731[8*i_14087731+4]
                f[5] = f_14087731[8*i_14087731+5]
                f[6] = f_14087731[8*i_14087731+6]
                f[7] = f_14087731[8*i_14087731+7]
                textmsg("current_object_location before offset = ", current_object_location_14087731)
                current_object_location_14087731 = pose_add(current_object_location_14087731, snapshot_position_offset)
                textmsg("current_object_location after offset = ", current_object_location_14087731)
                ruudukko2_OrJa = pose_trans(current_object_location_14087731, pose_trans(pose_inv(object_teaching_location), feature_teaching_location))
                $ 135 "foundGameMark≔2"
                global foundGameMark=2
                $ 136 "loc≔object_location"
                global loc=object_location
                $ 138 "Script: etsiRuutu_OrJa.script"
                	locatedX = loc[0]
                	locatedY = loc[1]
                
                
                	tempCounter = tempCounter + 1
                	dist = 71/1000
                	pos = -1
                
                	textmsg("sijainti, keskipiste")
                	textmsg(locatedX)
                	#textmsg(locatedX, " ", locatedY)
                	textmsg(locatedY)
                	#textmsg(locatedY)
                
                	#textmsg(middleX)
                	textmsg(middleX)
                	textmsg(middleY)
                	#textmsg(middleY)
                
                	if locatedX < (middleX - dist / 2):
                		# x--
                		# x--
                		# x--
                
                		if locatedY > (middleY + dist / 2):
                			# x--
                			# ---
                			# ---
                			pos = 0
                
                		elif locatedY < (middleY - dist / 2):
                			# ---
                			# ---
                			# x--
                			pos = 6
                
                		else:
                			# ---
                			# x--
                			# ---
                			pos = 3
                		end
                
                	# game markin valintaa varten hakualuetta rajataan tarkemmin
                	elif ((locatedX > (middleX + dist / 2)) and (locatedX < (middleX + dist * 1.5))):
                		# --x
                		# --x
                		# --x
                
                		if locatedY > (middleY + dist / 2):
                			# --x
                			# ---
                			# ---
                			pos = 2
                
                		elif locatedY < (middleY - dist / 2):
                			# ---
                			# ---
                			# --x
                			pos = 8
                
                		else:
                			# ---
                			# --x
                			# ---
                			pos = 5
                		end
                
                	#else:
                	elif ((locatedX > middleX - dist / 2) and (locatedX < middleX + dist / 2)):
                		# -x-
                		# -x-
                		# -x-
                
                		if locatedY > (middleY + dist / 2):
                			# -x-
                			# ---
                			# ---
                			pos = 1
                
                		elif locatedY < (middleY - dist / 2):
                			# ---
                			# ---
                			# -x-
                			pos = 7
                
                		#else:
                		elif ((locatedY > middleY - dist / 2) and (locatedY < middleY + dist / 2)):
                			# ---
                			# -x-
                			# ---
                			pos = 4
                		end
                	end
                
                	if pos != -1:
                		tempArray[pos] = foundGameMark
                	else:
                		#popup("Jokin meni pieleen")
                		textmsg("ei ruudukossa")
                	end
                i_14087731 = i_14087731 + 1
              end
              # end: URCap Program Node
              # Restore snapshot position
              ruudukko2_OrJa = p[0.0959887, -0.404572, 0.194291, -2.92107, 0.0142555, -0.0346137]
              
              #######VisionLocate node end########
              ###########################################
              
              # end: URCap Program Node
              $ 139 "Script: etsiMuutoksia_OrJa.script"
              
              	#ennen looppeja
              	# tempArray2 = [0,0,0, 0,0,0, 0,0,0]
              	# tempArray≔[0,0,0, 0,0,0, 0,0,0] viereen
              	tempArray2 = tempArray
              
              	arraysNotSame = 0
              	i = 0
              	# Vertailee taulukoita, joiden pitaisi olla samat
              	while i < 9:
              		if tempArray[i] != tempArray2[i]:
              			# Taulukot ei ole samoja
              			arraysNotSame = 1 # talla sittekun exit kusee
              			#textmsg("ei pitais menna tanne")
              			#tempArray2 = tempArray # arrayn siirto whilella??
              			#exit # kusee kumminkin, miksi edes yritetaan nain??
              		end
              		i = i +1
              	end
              
              	i = 0
              	if (arraysNotSame == 1):
              		while i < 9:
              			tempArray2[i] = tempArray[i]
              
              			i = i + 1
              		end
              		textmsg("tempArrayt")
              		textmsg(tempArray)
              		textmsg(tempArray2)
              	elif arraysNotSame == 0:
              		# onko tullut muutos pelilaudan tilanteesseen
              		i = 0
              		arrayChanged = 0
              
              
              		# Vertailee taulukoita, onko jonkin ruudun pelimerkki muuttunut
              		while i < 9:
              			if tempArray[i] != lastTurnArray[i]:
              				# Taulukossa tullut muutos
              				arrayChanged = 1
              				#break
              			end
              			i = i +1
              		end
              
              		# on tullut nappula lisaa pelialustalle
              		if ((tempCounter > counter) and (arrayChanged == 1)):
              			#textmsg("Counter, tempCounter")
              			#textmsg(counter)
              			#textmsg(tempCounter)
              			# Kun on tullut muutos
              			lastTurnArray = tempArray
              			# O = 1, X = 2
              			counter = tempCounter
              
              
              			# Lähetetään uusi boardi python koodille
              			socket_send_string("sending_board")
              			sleep(0.1)
              
              			socket_send_string(lastTurnArray[0])
              			sleep(0.05)
              			socket_send_string(lastTurnArray[1])
              			sleep(0.05)
              			socket_send_string(lastTurnArray[2])
              			sleep(0.05)
              
              			socket_send_string(lastTurnArray[3])
              			sleep(0.05)
              			socket_send_string(lastTurnArray[4])
              			sleep(0.05)
              			socket_send_string(lastTurnArray[5])
              			sleep(0.05)
              
              			socket_send_string(lastTurnArray[6])
              			sleep(0.05)
              			socket_send_string(lastTurnArray[7])
              			sleep(0.05)
              			socket_send_string(lastTurnArray[8])
              			sleep(0.05)
              
              			socket_send_string("end")
              
              		else:
              			arrayChanged = 0
              		end
              	end
              $ 140 "Wait: 0.1"
              sleep(0.1)
            end
            $ 141 "robotTurn≔1"
            global robotTurn=1
          else:
            $ 143 "ElseIf read ≟ 'gameover'"
            if (read  ==  "gameover"):
              $ 145 "Loop 2 times"
              Loop_8 = 0
              while (Loop_8 < 2):
                # begin: URCap Program Node
                #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
                #   Type: Gripper
                $ 146 "Gripper Move65% (1)"
                gripper_1_used = True
                if (connectivity_checked[0] != 1):
                  if not(rq_set_sid(9, "1")):
                    popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
                  end
                  connectivity_checked[0] = 1
                end
                if (status_checked[0] != 1):
                  if not(rq_is_gripper_activated("1")):
                    popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
                  end
                  status_checked[0] = 1
                end
                rq_set_speed(255, "1")
                current_speed[0] = 255
                rq_set_force(0, "1")
                current_force[0] = 0
                rq_set_pos(166, "1")
                rq_go_to("1")
                rq_wait("1")
                gripper_1_selected = True
                gripper_2_selected = False
                gripper_3_selected = False
                gripper_4_selected = False
                gripper_1_used = False
                gripper_2_used = False
                gripper_3_used = False
                gripper_4_used = False
                # end: URCap Program Node
                # begin: URCap Program Node
                #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
                #   Type: Gripper
                $ 147 "Gripper Move30% (1)"
                gripper_1_used = True
                if (connectivity_checked[0] != 1):
                  if not(rq_set_sid(9, "1")):
                    popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
                  end
                  connectivity_checked[0] = 1
                end
                if (status_checked[0] != 1):
                  if not(rq_is_gripper_activated("1")):
                    popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
                  end
                  status_checked[0] = 1
                end
                rq_set_speed(255, "1")
                current_speed[0] = 255
                rq_set_force(0, "1")
                current_force[0] = 0
                rq_set_pos(77, "1")
                rq_go_to("1")
                rq_wait("1")
                gripper_1_selected = True
                gripper_2_selected = False
                gripper_3_selected = False
                gripper_4_selected = False
                gripper_1_used = False
                gripper_2_used = False
                gripper_3_used = False
                gripper_4_used = False
                # end: URCap Program Node
                Loop_8 = Loop_8 + 1
              end
              # begin: URCap Program Node
              #   Source: Robotiq_Grippers, 1.4.1, Robotiq Inc.
              #   Type: Gripper
              $ 148 "Gripper Move34% (1)"
              gripper_1_used = True
              if (connectivity_checked[0] != 1):
                if not(rq_set_sid(9, "1")):
                  popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
                end
                connectivity_checked[0] = 1
              end
              if (status_checked[0] != 1):
                if not(rq_is_gripper_activated("1")):
                  popup("Gripper1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
                end
                status_checked[0] = 1
              end
              rq_set_speed(153, "1")
              current_speed[0] = 153
              rq_set_force(0, "1")
              current_force[0] = 0
              rq_set_pos(87, "1")
              rq_go_to("1")
              rq_wait("1")
              gripper_1_selected = True
              gripper_2_selected = False
              gripper_3_selected = False
              gripper_4_selected = False
              gripper_1_used = False
              gripper_2_used = False
              gripper_3_used = False
              gripper_4_used = False
              # end: URCap Program Node
              $ 149 "gameMark≔-1"
              global gameMark=-1
              $ 150 "lastTurnArray≔[0,0,0, 0,0,0, 0,0,0]"
              global lastTurnArray=[0,0,0, 0,0,0, 0,0,0]
              $ 151 "gameRunning≔0"
              global gameRunning=0
              $ 152 "counter≔0"
              global counter=0
              $ 153 "Wait: 5.0"
              sleep(5.0)
              $ 154 "robotTurn≔0"
              global robotTurn=0
              $ 155 "socket_send_string('oke')"
              socket_send_string("oke")
            end
          end
        end
        $ 156 "Wait: 1.0"
        sleep(1.0)
      end
    end
    $ 158 "socketOpen≔ False "
    global socketOpen=  False  
    $ 159 "socket_close()"
    socket_close()
  end
end
